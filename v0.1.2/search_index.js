var documenterSearchIndex = {"docs":
[{"location":"quick.html#Installation-1","page":"Quick Start","title":"Installation","text":"","category":"section"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"Currently, MolecularConformation.jl is not an registered package in Julia database, consequently, the best way to install is type ] in Julia REPL and then","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"pkg> add \"https://github.com/evcastelani/MolecularConformation.jl\"","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"If you want to setup some especific branch, is necessary just include the term #nameofbranch in the end of previous string. ","category":"page"},{"location":"quick.html#Basic-Usage-1","page":"Quick Start","title":"Basic Usage","text":"","category":"section"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"First of all, we need to load the package. ","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tusing MolecularConformation","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"In order to conformalize some structure,  we need to get a list in .nmr format. This kind of list can get, for example, here. ","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"warning:  'Warning' \nCurrently, MolecularConformation.jl works only with file in .nmr format. ","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"Since we have the list in this format, we must transform the data to NMRType format. The simplest way to do this is through the preprocessing function. An NMRType element contains information about order, additional distances and other elements that can be used to optimize the solver. The preprocessing function can handle with the .nmr file and provides a NMRType with all necessary information.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tdata_example = preprocessing(\"toyinstance.nmr\")","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"Note that the type of data_example is a NMRType","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\ttypeof(data_example)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"which means that data_example is has four fields.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tfieldnames(NMRType)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"One of most important fields is .info. This field is a symmetric CSVSparseMatrix where each input value is a NMRInfo element. This kind of structure provides a fast acess and considerable storage savings. A NMRInfo element contains information about the distance and two bond atoms.  ","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tfieldnames(NMRInfo)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"Once the type of data this package handles is well established, let's look at the rest of the settings until the main function is executed. The next step is to define the options to be used for the solver. For this, we need to create a ConformationSetup. This kind of element has four fields but one is optional (virtual_precision).","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tfieldnames(ConformationSetup)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"The precision  will be used by the pruning test of the solver. The solver is the name of the function that was choose and allsolution is a bolean parameter for detect all solution if it is set as true.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\topt = ConformationSetup(0.000001,MolecularConformation.classicBP,false)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"Now all that is required to execute the algorithm is ready and therefore, let us run the conformation function. ","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tsol = conformation(data_example,opt)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"In our example, the solution is storage in sol whose type is ConformationOutput.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\ttypeof(sol)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"The ConformationOutput type, has the following fields.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tfieldnames(ConformationOutput)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"The field number corresponds to the number of solutions. The field molecules is a dictionary of where associated to each key we have a solution of MoleculeType.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\ttypeof(sol.molecules[1])","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"A MoleculeType has two fields.","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tfieldnames(MoleculeType)","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"In our example this has the following values","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"\tsol.molecules[1].atoms\n\tsol.molecules[1].lde","category":"page"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"The other fields of ConformationOutput are self-explanatory and used to just to analyze the performance of the method.","category":"page"},{"location":"quick.html#About-the-solvers-1","page":"Quick Start","title":"About the solvers","text":"","category":"section"},{"location":"quick.html#","page":"Quick Start","title":"Quick Start","text":"Currently, just one solver is available: ClassicBP ","category":"page"},{"location":"api.html#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#","page":"API","title":"API","text":"We can summarize the main functions of this package as follows.","category":"page"},{"location":"api.html#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api.html#","page":"API","title":"API","text":"NMRInfo\nNMRType\nAtomType\nMoleculeType\nConformationSetup\nConformationOutput","category":"page"},{"location":"api.html#MolecularConformation.NMRInfo","page":"API","title":"MolecularConformation.NMRInfo","text":"NMRinfo :: Type\n\nThis type contains the information for NMRtype. In this point of the project it contains two fields: dist, atom1 and atom2. Essentially, dist is the distance between atom1 and atom2 which are strings related to the name of atoms.  \n\n\n\n\n\n","category":"type"},{"location":"api.html#MolecularConformation.NMRType","page":"API","title":"MolecularConformation.NMRType","text":"NMRType :: Type\n\nThis type is used as input data. Essentially, this type carry itself fields for internal solvers. Although it is possible to input data directly into the type, it is highly recommended that this type be constructed from the function preprocessing, like in the following example \n\nExample\n\nnmr_data_example = preprocessing(\"1A57.nmr\")\n\nAs return an element of NMRtype is created. We are assuming that a 1A57.nmr file is provided.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MolecularConformation.AtomType","page":"API","title":"MolecularConformation.AtomType","text":"AtomType :: Type\n\nIt is the most primitive type and it is used to store the spatial positions of atoms. It is a mutable type. This type has three field: .x, .y and .z\n\n\n\n\n\n","category":"type"},{"location":"api.html#MolecularConformation.MoleculeType","page":"API","title":"MolecularConformation.MoleculeType","text":"MoleculeType :: Type\n\nIt is used to store a (just one) solution find by conformation process. It is a mutable struct and has two fields: .atoms (used to store a vector of AtomType) and .lde (used to store the lde of an molecule)\n\n\n\n\n\n","category":"type"},{"location":"api.html#MolecularConformation.ConformationSetup","page":"API","title":"MolecularConformation.ConformationSetup","text":"ConformationSetup :: Type\n\nThis type is used to define the main options of the function used to conformation. Essentially, this type has three fields: precision, solver, allsolutions. \n\nprecision ::  is associated to current internal solver which depends on some level do a pruning test.\n\nsolver :: is the name of function which define the solver. \n\nallsolution :: is a bool variable used to define the behavior of the method. Is set as true, the internal solver try to find all possible solutions. \n\nExample\n\noptions = ConformationSetup(0.00001,classicBP,true)\n\nAs return an element options was created an it will used in conformation function. It is a mandatory definition before run conformation function.\n\n\n\n\n\n","category":"type"},{"location":"api.html#MolecularConformation.ConformationOutput","page":"API","title":"MolecularConformation.ConformationOutput","text":"ConformationOutput :: Type\n\nIt is a mutable type used to store the output provided by conformation function. With this type is possible to handle with some importants elements given by the following fields:.number,.molecules,.elapsedtime,.bytes and .gctime\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main-functions-1","page":"API","title":"Main functions","text":"","category":"section"},{"location":"api.html#","page":"API","title":"API","text":"preprocessing(file::String,opt=\"read\")\nconformation(NMRdata::NMRType,cs::ConformationSetup)\nclassicBP(NMRdata :: NMRType,ε :: Float64,virtual_ε :: Float64,allmol :: Bool)\nLDE(v::MoleculeType,D::NMRType)\nbuild_distance_matrix(v::Array{AtomType,1})","category":"page"},{"location":"api.html#MolecularConformation.preprocessing","page":"API","title":"MolecularConformation.preprocessing","text":"preprocessing :: Function\n\nThis function is able to read a .nmr file and generate a NMRType, which is an internal type with fields that can be used by internals solvers. Given a list in .nmr format, let us say the 1A57.nmr file, the following example show how simple is to use this function.\n\nExample\n\npreprocessing(\"1A57.nmr\")\n\n\n\n\n\n","category":"function"},{"location":"api.html#MolecularConformation.conformation-Tuple{NMRType,ConformationSetup}","page":"API","title":"MolecularConformation.conformation","text":"conformation(NMRdata,cs::ConformationSetup)\n\n\nThis is the main function in order to get the conformation of a molecule. To run this function, we need to setup a NMR file and then define some options using the ConformationSetup type. \n\nExample\n\njulia> options = ConformationSetup(0.001,classicBP,true)\n\njulia> conformation(NMRdata,options)\n\nas return a ConformationOutput type is provided.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MolecularConformation.classicBP-Tuple{NMRType,Float64,Float64,Bool}","page":"API","title":"MolecularConformation.classicBP","text":"classicBP :: Function\n\nThis function is an important solver of this package. This solver implements the algorithm given in \n\nLiberti, L., Lavor, C., & Maculan, N. (2008). A branch‐and‐prune algorithm for the molecular distance geometry problem. International Transactions in Operational Research, 15(1), 1-17.\n\nThe main difference of our implementation is that the input data (NMRType) can store informations of preprocessing function and as consequence we can optimize the search tree of this algorithm. \n\n\n\n\n\n","category":"method"},{"location":"api.html#MolecularConformation.LDE-Tuple{MoleculeType,NMRType}","page":"API","title":"MolecularConformation.LDE","text":"LDE :: Function\n\nThis function is an auxiliary function used to compute the LDE of some molecule. This function change the .lde field of the molecule.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MolecularConformation.build_distance_matrix-Tuple{Array{AtomType,1}}","page":"API","title":"MolecularConformation.build_distance_matrix","text":"build_distance_matrix\n\nThis function can be useful to visualize a the distance array associated to an MoleculeType solution\n\nExample\n\nv = conformation(data,opt)\nbuild_distance_array(v.molecules[1].atoms)\n\n\n\n\n\n\n","category":"method"},{"location":"api.html#Secundary-functions-1","page":"API","title":"Secundary functions","text":"","category":"section"},{"location":"api.html#","page":"API","title":"API","text":"This functions are used as auxiliary functions by internal solvers.","category":"page"},{"location":"api.html#","page":"API","title":"API","text":"bondangle(d23,d24,d34)\ntorsionangle(d12,d13,d14,d23,d24,d34)\ntorsionmatrix(cosθ,sinθ,cosω,sinω,d34,sign::Bool)\npruningtest(v::MoleculeType,i::Int,D::NMRType,ε::Float64)","category":"page"},{"location":"api.html#MolecularConformation.bondangle-Tuple{Any,Any,Any}","page":"API","title":"MolecularConformation.bondangle","text":"bondangle :: Function\n\nThis is an auxiliary function used by ClassicBP solver in order to compute the bond angle by cosine rule. As output the cosine and sine are given.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MolecularConformation.torsionangle-NTuple{6,Any}","page":"API","title":"MolecularConformation.torsionangle","text":"torsionangle :: Function\n\nThis is an auxiliary function used by ClassicBP solver in order to compute the torsion angle. As output the cosine and sine of the torsion angle are given.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MolecularConformation.torsionmatrix-Tuple{Any,Any,Any,Any,Any,Bool}","page":"API","title":"MolecularConformation.torsionmatrix","text":"torsionmatrix :: Function\n\nThis is an auxiliary function  used by ClassicBP solver to compute the torsion array.\n\n\n\n\n\n","category":"method"},{"location":"api.html#MolecularConformation.pruningtest-Tuple{MoleculeType,Int64,NMRType,Float64}","page":"API","title":"MolecularConformation.pruningtest","text":"pruningtest :: Function\n\nThis functions is an auxiliary function used to test if some molecule is  feasible or not.\n\n\n\n\n\n","category":"method"},{"location":"index.html#MolecularConformation.jl-1","page":"Home","title":"MolecularConformation.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Nuclear Magnetic Resonance (NMR) experiments provide distances between atoms of a protein molecule. Using these distance the conformation molecular problem is to determine the 3D protein structur. This package is a class of solvers to get the spatial arrangement of the atoms in a molecule. The focus of this project is to establish a friendly environment to perform simulations, visualize solutions, interact with other environments such as BioStructures.jl and, mainly, to develop new NMR-based molecular conformation methods.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"note: Note\nCurrently, the solvers related to this package are able to determine the position of atoms of the backbone chain of a molecule.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The main inspirations for this work are given by:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[1] Liberti, L., Lavor, C., & Maculan, N. (2008). A branch‐and‐prune algorithm for the molecular distance geometry problem. International Transactions in Operational Research, 15(1), 1-17.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[2] Lavor, C., Liberti, L., & Mucherino, A. (2013). The interval Branch-and-Prune algorithm for the discretizable molecular distance geometry problem with inexact distances. Journal of Global Optimization, 56(3), 855-871.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[3] Mucherino, A., Liberti, L., & Lavor, C. (2010, September). MD-jeep: an implementation of a branch and prune algorithm for distance geometry problems. In International Congress on Mathematical Software (pp. 186-197). Springer, Berlin, Heidelberg.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[4] Lavor, C., Liberti, L., Donald, B., Worley, B., Bardiaux, B., Malliavin, T. E., & Nilges, M. (2019). Minimal NMR distance information for rigidity of protein graphs. Discrete Applied Mathematics, 256, 91-104.","category":"page"},{"location":"index.html#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Credits-1","page":"Home","title":"Credits","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Felipe Fidalgo\nGuilherme Philip\nEmerson V. Castelani","category":"page"}]
}
